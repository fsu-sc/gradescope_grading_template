# print('type dict NOT HANDLED!')
# print('type set[set] NOT HANDLED!')
types:
  NDArray: 
    import: "" #"numpy as np"
    #assert: "isinstance({answer_var}, type(np.zeros(1)))"
    assert_answer: "assert_utilities.check_answer_NDArray(student_answer, instructor_answer, rel_tol)"
    assert_structure: "assert_utilities.check_structure_NDArray(student_answer, instructor_answer)"
      #answer_msg: "Correct answer: \n Matrix shapes, type, and norms"

  function: 
    import: ""
    assert_answer: "assert_utilities.check_answer_function(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_function(student_answer, instructor_answer)"

  float:
    import: ""
    assert_answer: "assert_utilities.check_answer_float(student_answer, instructor_answer, rel_tol)"
    assert_structure: "assert_utilities.check_structure_float(student_answer, instructor_answer)"

  int:
    import: ""
    assert_answer: "assert_utilities.check_answer_int(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_int(student_answer, instructor_answer)"
    # aliases: integer  (not yet implemented)

  integer:
    import: ""
    assert_answer: "assert_utilities.check_answer_int(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_int(student_answer, instructor_answer)"

  list:
    import: ""
    assert: "isinstance({answer_var}, list)"
    struct_msg: Answer should be a list. 

  list[list]:
    import: "" #"numpy as np"
    assert: "isinstance({answer_var}, list) and isinstance({answer_var}[0], list)"
    struct_msg: Answer should be a list of lists of floats

  list[set]:
    import: "" #"numpy as np"
    assert_answer: "assert_utilities.check_answer_list_set(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_list_set(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  set[set]:
    import: "" #"numpy as np"
    assert_answer: "assert_utilities.check_answer_set_set(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_set_set(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  list[list[float]]:
    import: ""
    # Fix for structure
    assert_answer: "assert_utilities.check_answer_list_list_float(student_answer, instructor_answer, rel_tol)"
    assert_structure: "assert_utilities.check_structure_list_list_float(student_answer, instructor_answer)"
 
  list[NDArray]:
    import: "" #"numpy as np"
    assert_answer: "assert_utilities.check_answer_list_NDArray(student_answer, instructor_answer, rel_tol)"
    assert_structure: "assert_utilities.check_structure_list_NDArray(student_answer, instructor_answer)"
    #answer_msg: ""

  list[string]:
    import: ""
    assert_answer: "assert_utilities.check_answer_list_string(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_list_string(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  set:
    import: ""
    assert: "isinstance({answer_var}, set)"
    struct_msg: Answer should be of type set. 
    note: a set of objects (any type, mostly strings), TBD

  set[string]:
    import: ""
    assert_answer: "assert_utilities.check_answer_set_string(student_answer, instructor_answer, choices)"
    assert_structure: "assert_utilities.check_structure_set_string(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  bool:
    import: ""
    assert_answer: "assert_utilities.check_answer_bool(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_bool(student_answer, instructor_answer)"
    #struct_msg: Answer should be a bool. 

  choice:
    import: ""
    assert: "{answer_var} in {valid_choices}"
    #struct_msg: Answer should one of {valid_choices}. 

  float_range:
    import: ""
    assert: "isinstance({answer_var}, float) and {range_check}"
    struct_msg: Answer should be a float in a specified range (WHAT IS THE RANGE?). 
    note: What is the range? 

  dict:
    import: ""
    assert_answer: "assert_utilities.check_answer_dict(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_dict(student_answer, instructor_answer)"

  dict_str_str:
    import: ""
    assert: "isinstance({answer_var}, dict) and all(isinstance(k, str) and isinstance(v, str) for k, v in {answer_var}.items())"
    struct_msg: "Answer should be dictionary, specifically: dict[str, str]."

  dict[string,dict[str,list]]:
    import: ""
    assert_answer: "assert_utilities.check_answer_dict_string_dict_str_list(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_dict_string_dict_str_list(student_answer, instructor_answer)"

  explain_string:
    import: ""
    assert_answer: "assert_utilities.check_answer_explain_string(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_explain_string(student_answer, instructor_answer)"
    min_words: 10  # Should be in the configuration file

  dict[string,list]:
    import: ""
    assert: "isinstance({answer_var}, dict) and all(isinstance(k, str) and isinstance(v, list) for k, v in {answer_var}.items())"
    struct_msg: "Answer should be dictionary, specifically: dict[str, str]."

  dict[string,set]:
    import: ""
    # a set of non-strings
    assert_answer: "assert_utilities.check_answer_dict_string_set(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_dict_string_set(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  dict[string,float]:
    import: ""
    assert_answer: "assert_utilities.check_answer_dict_string_float(student_answer, instructor_answer, rel_tol, keys)"
    assert_structure: "assert_utilities.check_structure_dict_string_float(student_answer, instructor_answer, rel_tol, keys)"

  dict[str,float]:
    import: ""
    assert_answer: "assert_utilities.check_answer_dict_string_float(student_answer, instructor_answer, rel_tol, keys)"
    assert_structure: "assert_utilities.check_structure_dict_string_float(student_answer, instructor_answer, rel_tol, keys)"

  dict[string,NDArray]:
    import: "" #"numpy as np"
    #assert: "isinstance({answer_var}, list) and isinstance({answer_var}[0], type(np.zeros(3)))"
    # Test that the norms of the matrix are within a tolerance
    # I should be able to test the length against the expected length, either from the instructor answer
    #    or from the answer specified in the yaml file, or against a length specified in the yaml file. NOT DONE.
    assert_answer: "assert_utilities.check_answer_dict_string_NDArray(student_answer, instructor_answer, rel_tol, keys)"
    assert_structure: "assert_utilities.check_structure_dict_string_NDArray(student_answer, instructor_answer, rel_tol, keys)"
    #answer_msg: "Correct answer: {instructor_answer}"

  dict[string,Tuple[NDArray]]:
    import: "" #"numpy as np"
    # Not implemented correctly
    #assert: "isinstance({answer_var}, list) and isinstance({answer_var}[0], type(np.zeros(3)))"  
    # The instructor answer is useful to check key values
    assert_answer: "assert_utilities.check_answer_dict_string_Tuple_NDArray(student_answer, instructor_answer, rel_tol)"
    assert_structure: "assert_utilities.check_structure_dict_string_Tuple_NDArray(student_answer, instructor_answer)"
    #answer_msg: "Correct answer: {instructor_answer}"

  dict_str_list:
    import: ""
    assert: "isinstance({answer_var}, dict) and all(isinstance(k, str) and isinstance(v, list) for k, v in {answer_var}.items())"
    truct_msg: "Answer should be dictionary, specifically: dict[str, str]."


  dict_str_dict_str_float:
    import: ""
    assert: "isinstance({answer_var}, dict) and all(isinstance(k, str) and isinstance(v, dict) and all(isinstance(sub_k, str) and isinstance(sub_v, float) for sub_k, sub_v in v.items()) for k, v in {answer_var}.items())"
    struct_msg: "Answer should be dictionary, specifically: dict[str, dict[str, float]]."

  str:
    import: ""
    assert_answer: "assert_utilities.check_answer_string(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_string(student_answer, instructor_answer, choices)"

  string:
    import: ""
    assert_answer: "assert_utilities.check_answer_string(student_answer, instructor_answer)"
    assert_structure: "assert_utilities.check_structure_string(student_answer, instructor_answer, choices)"

  # Evaluate to a float
  eval_float:
    import: ""
    assert_answer: "assert_utilities.check_answer_eval_float(student_answer, instructor_answer, local_vars_dict, rel_tol)"
    assert_structure: "assert_utilities.check_structure_eval_float(student_answer, instructor_answer, local_vars_dict, rel_tol)"
    help: >
      A string to be evaluated using eval(). It will be important
      that the variables defined in the string be available in the 
      context. It is not yet clear how to implement this. Exponentiation is expressed 
      with either '^' or '**'. Except for this, the string must be a valid Python expression.

  DecisionTreeClassifier:
    import: "from sklearn.tree import DecisionTreeClassifier"
    assert: "isinstance({answer_var}, DecisionTreeClassifier)"
    struct_msg: Answer should be a DecisionTreeClassifier instance. 

  dendrogram: 
    import: ""
    # Return from Dendrogram function
    #assert: "isinstance({answer_var}, dict"
    assert_answer: "assert_utilities.check_answer_dendrogram(student_answer, instructor_answer, rel_tol)"
    #answer_msg: "Correct answer: {instructor_answer}"
    assert_structure: "assert_utilities.check_structure_dendrogram(student_answer, instructor_answer)"

